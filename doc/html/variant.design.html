<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Design Overview</title><link rel="stylesheet" href="reference.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.61.3"><link rel="home" href="index.html" title="The Boost C++ Libraries"><link rel="up" href="variant.html" title="Boost.Variant"><link rel="previous" href="id2544445-bb.html" title="Function template visitor_ptr"><link rel="next" href="variant.misc.html" title="Miscellaneous Notes"><link rel="chapter" href="libraries.html" title="The Boost C++ Libraries"><link rel="chapter" href="any.html" title="Boost.Any"><link rel="refentry" href="class.boost.bad_any_cast.html" title="Class bad_any_cast"><link rel="refentry" href="class.boost.any.html" title="Class any"><link rel="refentry" href="id2383300-bb.html" title="Function any_cast"><link rel="chapter" href="array.html" title="Boost.Array"><link rel="refentry" href="class.boost.array.html" title="Class template array"><link rel="chapter" href="function.html" title="Boost.Function"><link rel="refentry" href="class.boost.bad_function_call.html" title="Class bad_function_call"><link rel="refentry" href="class.boost.function_base.html" title="Class function_base"><link rel="refentry" href="class.boost.functionN.html" title="Class template functionN"><link rel="refentry" href="class.boost.function.html" title="Class template function"><link rel="chapter" href="ref.html" title="Boost.Ref"><link rel="refentry" href="class.boost.reference_wrapper.html" title="Class template reference_wrapper"><link rel="refentry" href="class.boost.is_reference_wrapper.html" title="Class template is_reference_wrapper"><link rel="refentry" href="class.boost.unwrap_reference.html" title="Class template unwrap_reference"><link rel="chapter" href="signals.html" title="Boost.Signals"><link rel="refentry" href="class.boost.signalN.html" title="Class template signalN"><link rel="refentry" href="class.boost.signal.html" title="Class template signal"><link rel="refentry" href="class.boost.slot.html" title="Class template slot"><link rel="refentry" href="class.boost.signals.trackable.html" title="Class trackable"><link rel="refentry" href="class.boost.signals.connection.html" title="Class connection"><link rel="refentry" href="class.boost.signals.scoped_connection.html" title="Class scoped_connection"><link rel="refentry" href="id2532119-bb.html" title="Function template visit_each"><link rel="refentry" href="class.boost.last_value.html" title="Class template last_value"><link rel="refentry" href="id2354683-bb.html" title="Class last_value&lt;void&gt;"><link rel="chapter" href="variant.html" title="Boost.Variant"><link rel="refentry" href="BOOST_VARIANT_LIMIT_TYPES.html" title="Macro BOOST_VARIANT_LIMIT_TYPES"><link rel="refentry" href="BOOST_VARIANT_ENUM_PARAMS.html" title="Macro BOOST_VARIANT_ENUM_PARAMS"><link rel="refentry" href="BOOST_VARIANT_ENUM_SHIFTED_PARAMS.html" title="Macro BOOST_VARIANT_ENUM_SHIFTED_PARAMS"><link rel="refentry" href="BOOST_VARIANT_NO_REFERENCE_SUPPORT.html" title="Macro BOOST_VARIANT_NO_REFERENCE_SUPPORT"><link rel="refentry" href="BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT.html" title="Macro BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT"><link rel="refentry" href="BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT.html" title="Macro BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT"><link rel="refentry" href="class.boost.variant.html" title="Class template variant"><link rel="refentry" href="id2518553-bb.html" title="Function template swap"><link rel="refentry" href="id2524211-bb.html" title="Function template operator&lt;&lt;"><link rel="refentry" href="class.boost.make_variant_over.html" title="Class template make_variant_over"><link rel="refentry" href="class.boost.make_recursive_variant.html" title="Class template make_recursive_variant"><link rel="refentry" href="class.boost.make_recursive_variant_over.html" title="Class template make_recursive_variant_over"><link rel="refentry" href="class.boost.recursive_wrapper.html" title="Class template recursive_wrapper"><link rel="refentry" href="class.boost.is_recursive_wrapper.html" title="Class template is_recursive_wrapper"><link rel="refentry" href="class.boost.unwrap_recursive_wrapper.html" title="Class template unwrap_recursive_wrapper"><link rel="refentry" href="class.boost.apply_visitor_delayed_t.html" title="Class template apply_visitor_delayed_t"><link rel="refentry" href="id2557051-bb.html" title="Function apply_visitor"><link rel="refentry" href="class.boost.bad_get.html" title="Class bad_get"><link rel="refentry" href="id2493238-bb.html" title="Function get"><link rel="refentry" href="class.boost.bad_visit.html" title="Class bad_visit"><link rel="refentry" href="class.boost.static_visitor.html" title="Class template static_visitor"><link rel="refentry" href="class.boost.visitor_ptr_t.html" title="Class template visitor_ptr_t"><link rel="refentry" href="id2544445-bb.html" title="Function template visitor_ptr"><link rel="chapter" href="boostbook.html" title="The BoostBook Documentation Format"><link rel="refentry" href="boostbook.dtd.class-specialization.html" title="
          BoostBook element class-specialization"><link rel="refentry" href="boostbook.dtd.link-test.html" title="
          BoostBook element link-test"><link rel="refentry" href="boostbook.dtd.link-fail-test.html" title="
          BoostBook element link-fail-test"><link rel="refentry" href="boostbook.dtd.typedef.html" title="
          BoostBook element typedef"><link rel="refentry" href="boostbook.dtd.static-constant.html" title="
          BoostBook element static-constant"><link rel="refentry" href="boostbook.dtd.code.html" title="
          BoostBook element code"><link rel="refentry" href="boostbook.dtd.destructor.html" title="
          BoostBook element destructor"><link rel="refentry" href="boostbook.dtd.template-type-parameter.html" title="
          BoostBook element template-type-parameter"><link rel="refentry" href="boostbook.dtd.description.html" title="
          BoostBook element description"><link rel="refentry" href="boostbook.dtd.librarylist.html" title="
          BoostBook element librarylist"><link rel="refentry" href="boostbook.dtd.library-reference.html" title="
          BoostBook element library-reference"><link rel="refentry" href="boostbook.dtd.boostbook.html" title="
          BoostBook element boostbook"><link rel="refentry" href="boostbook.dtd.union.html" title="
          BoostBook element union"><link rel="refentry" href="boostbook.dtd.inherit.html" title="
          BoostBook element inherit"><link rel="refentry" href="boostbook.dtd.template-varargs.html" title="
          BoostBook element template-varargs"><link rel="refentry" href="boostbook.dtd.source.html" title="
          BoostBook element source"><link rel="refentry" href="boostbook.dtd.function.html" title="
          BoostBook element function"><link rel="refentry" href="boostbook.dtd.postconditions.html" title="
          BoostBook element postconditions"><link rel="refentry" href="boostbook.dtd.compile-test.html" title="
          BoostBook element compile-test"><link rel="refentry" href="boostbook.dtd.method.html" title="
          BoostBook element method"><link rel="refentry" href="boostbook.dtd.snippet.html" title="
          BoostBook element snippet"><link rel="refentry" href="boostbook.dtd.constructor.html" title="
          BoostBook element constructor"><link rel="refentry" href="boostbook.dtd.namespace.html" title="
          BoostBook element namespace"><link rel="refentry" href="boostbook.dtd.if-fails.html" title="
          BoostBook element if-fails"><link rel="refentry" href="boostbook.dtd.free-function-group.html" title="
          BoostBook element free-function-group"><link rel="refentry" href="boostbook.dtd.functionname.html" title="
          BoostBook element functionname"><link rel="refentry" href="boostbook.dtd.librarycategory.html" title="
          BoostBook element librarycategory"><link rel="refentry" href="boostbook.dtd.notes.html" title="
          BoostBook element notes"><link rel="refentry" href="boostbook.dtd.data-member.html" title="
          BoostBook element data-member"><link rel="refentry" href="boostbook.dtd.specialization.html" title="
          BoostBook element specialization"><link rel="refentry" href="boostbook.dtd.union-specialization.html" title="
          BoostBook element union-specialization"><link rel="refentry" href="boostbook.dtd.throws.html" title="
          BoostBook element throws"><link rel="refentry" href="boostbook.dtd.template-arg.html" title="
          BoostBook element template-arg"><link rel="refentry" href="boostbook.dtd.method-group.html" title="
          BoostBook element method-group"><link rel="refentry" href="boostbook.dtd.requirement.html" title="
          BoostBook element requirement"><link rel="refentry" href="boostbook.dtd.precondition.html" title="
          BoostBook element precondition"><link rel="refentry" href="boostbook.dtd.paramtype.html" title="
          BoostBook element paramtype"><link rel="refentry" href="boostbook.dtd.using-class.html" title="
          BoostBook element using-class"><link rel="refentry" href="boostbook.dtd.run-test.html" title="
          BoostBook element run-test"><link rel="refentry" href="boostbook.dtd.librarypurpose.html" title="
          BoostBook element librarypurpose"><link rel="refentry" href="boostbook.dtd.copy-assignment.html" title="
          BoostBook element copy-assignment"><link rel="refentry" href="boostbook.dtd.run-fail-test.html" title="
          BoostBook element run-fail-test"><link rel="refentry" href="boostbook.dtd.template.html" title="
          BoostBook element template"><link rel="refentry" href="boostbook.dtd.compile-fail-test.html" title="
          BoostBook element compile-fail-test"><link rel="refentry" href="boostbook.dtd.returns.html" title="
          BoostBook element returns"><link rel="refentry" href="boostbook.dtd.default.html" title="
          BoostBook element default"><link rel="refentry" href="boostbook.dtd.parameter.html" title="
          BoostBook element parameter"><link rel="refentry" href="boostbook.dtd.signature.html" title="
          BoostBook element signature"><link rel="refentry" href="boostbook.dtd.overloaded-function.html" title="
          BoostBook element overloaded-function"><link rel="refentry" href="boostbook.dtd.class.html" title="
          BoostBook element class"><link rel="refentry" href="boostbook.dtd.librarycategorydef.html" title="
          BoostBook element librarycategorydef"><link rel="refentry" href="boostbook.dtd.type.html" title="
          BoostBook element type"><link rel="refentry" href="boostbook.dtd.enumvalue.html" title="
          BoostBook element enumvalue"><link rel="refentry" href="boostbook.dtd.overloaded-method.html" title="
          BoostBook element overloaded-method"><link rel="refentry" href="boostbook.dtd.programlisting.html" title="
          BoostBook element programlisting"><link rel="refentry" href="boostbook.dtd.complexity.html" title="
          BoostBook element complexity"><link rel="refentry" href="boostbook.dtd.purpose.html" title="
          BoostBook element purpose"><link rel="refentry" href="boostbook.dtd.template-nontype-parameter.html" title="
          BoostBook element template-nontype-parameter"><link rel="refentry" href="boostbook.dtd.library.html" title="
          BoostBook element library"><link rel="refentry" href="boostbook.dtd.librarycategorylist.html" title="
          BoostBook element librarycategorylist"><link rel="refentry" href="boostbook.dtd.using-namespace.html" title="
          BoostBook element using-namespace"><link rel="refentry" href="boostbook.dtd.struct-specialization.html" title="
          BoostBook element struct-specialization"><link rel="refentry" href="boostbook.dtd.struct.html" title="
          BoostBook element struct"><link rel="refentry" href="boostbook.dtd.lib.html" title="
          BoostBook element lib"><link rel="refentry" href="boostbook.dtd.enum.html" title="
          BoostBook element enum"><link rel="refentry" href="boostbook.dtd.requires.html" title="
          BoostBook element requires"><link rel="refentry" href="boostbook.dtd.effects.html" title="
          BoostBook element effects"><link rel="refentry" href="boostbook.dtd.libraryname.html" title="
          BoostBook element libraryname"><link rel="refentry" href="boostbook.dtd.libraryinfo.html" title="
          BoostBook element libraryinfo"><link rel="refentry" href="boostbook.dtd.testsuite.html" title="
          BoostBook element testsuite"><link rel="refentry" href="boostbook.dtd.header.html" title="
          BoostBook element header"><link rel="refentry" href="boostbook.dtd.rationale.html" title="
          BoostBook element rationale"><link rel="refentry" href="Assignable.html" title="Concept Assignable"><link rel="refentry" href="InputIterator.html" title="Concept InputIterator"><link rel="refentry" href="OutputIterator.html" title="Concept OutputIterator"><link rel="refentry" href="ForwardIterator.html" title="Concept ForwardIterator"><link rel="refentry" href="BidirectionalIterator.html" title="Concept BidirectionalIterator"><link rel="refentry" href="RandomAccessIterator.html" title="Concept RandomAccessIterator"><link rel="refentry" href="DefaultConstructible.html" title="Concept DefaultConstructible"><link rel="refentry" href="CopyConstructible.html" title="Concept CopyConstructible"><link rel="refentry" href="EqualityComparable.html" title="Concept EqualityComparable"><link rel="refentry" href="LessThanComparable.html" title="Concept LessThanComparable"><link rel="refentry" href="SignedInteger.html" title="Concept SignedInteger"><link rel="subsection" href="variant.design.html#variant.design.never-empty" title='"Never-Empty" Guarantee'></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" border="1" cellpadding="2" bgcolor="#007F7F"><tr><td bgcolor="#FFFFFF"><img src="../../c++boost.gif" alt="c++boost.gif (8819 bytes)" width="277" height="86"></td><td><a href="../../index.htm"><font color="#FFFFFF" size="4" face="Arial">Home</font></a></td><td><a href="libraries.html"><font color="#FFFFFF" size="4" face="Arial">Libraries</font></a></td><td><a href="../../people/people.htm"><font color="#FFFFFF" size="4" face="Arial">People</font></a></td><td><a href="../../more/faq.htm"><font color="#FFFFFF" size="4" face="Arial">FAQ</font></a></td><td><a href="../../more/index.htm"><font color="#FFFFFF" size="4" face="Arial">More</font></a></td></tr></table><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="variant.design"></a>Design Overview</h3></div></div><div></div></div><div class="toc"><dl><dt><a href="variant.design.html#variant.design.never-empty">"Never-Empty" Guarantee</a></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="variant.design.never-empty"></a>"Never-Empty" Guarantee</h4></div></div><div></div></div><div class="toc"><dl><dt><a href="variant.design.html#variant.design.never-empty.guarantee">The Guarantee</a></dt><dt><a href="variant.design.html#variant.design.never-empty.problem">The Implementation Problem</a></dt><dt><a href="variant.design.html#variant.design.never-empty.memcpy-solution">The "Ideal" Solution: False Hopes</a></dt><dt><a href="variant.design.html#variant.design.never-empty.double-storage-solution">An Initial Solution: Double Storage</a></dt><dt><a href="variant.design.html#variant.design.never-empty.heap-backup-solution">Current Approach: Temporary Heap Backup</a></dt><dt><a href="variant.design.html#variant.design.never-empty.optimizations">Enabling Optimizations</a></dt><dt><a href="variant.design.html#variant.design.never-empty.roadmap">Future Direction: Policy-based Implementation</a></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="variant.design.never-empty.guarantee"></a>The Guarantee</h5></div></div><div></div></div><p>All instances <tt class="computeroutput">v</tt> of type
        <tt class="computeroutput"><a href="class.boost.variant.html" title="Class template variant">variant</a>&lt;T1,T2,...,TN&gt;</tt>
        guarantee that <tt class="computeroutput">v</tt> has constructed content of one of the
        types <tt class="computeroutput">T<span class="emphasis"><em>i</em></span></tt>, even if an operation on
        <tt class="computeroutput">v</tt> has previously failed.</p><p>This implies that <tt class="computeroutput">variant</tt> may be viewed precisely as
        a union of <span class="emphasis"><em>exactly</em></span> its bounded types. This
        "never-empty" property insulates the user from the
        possibility of undefined <tt class="computeroutput">variant</tt> content and the
        significant additional complexity-of-use attendant with such a
        possibility.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="variant.design.never-empty.problem"></a>The Implementation Problem</h5></div></div><div></div></div><p>While the
        <a href="variant.design.html#variant.design.never-empty.guarantee" title="The Guarantee">never-empty guarantee</a>
        might at first seem "obvious," it is in fact not even
        straightforward how to implement it in general (i.e., without
        unreasonably restrictive additional requirements on
        <a href="">bounded types</a>).</p><p>The central difficulty emerges in the details of
        <tt class="computeroutput">variant</tt> assignment. Given two instances <tt class="computeroutput">v1</tt>
        and <tt class="computeroutput">v2</tt> of some concrete <tt class="computeroutput">variant</tt> type, there
        are two distinct, fundamental cases we must consider for the assignment
        <tt class="computeroutput">v1 = v2</tt>.</p><p>First consider the case that <tt class="computeroutput">v1</tt> and <tt class="computeroutput">v2</tt>
        each contains a value of the same type. Call this type <tt class="computeroutput">T</tt>.
        In this situation, assignment is perfectly straightforward: use
        <tt class="computeroutput">T::operator=</tt>.</p><p>However, we must also consider the case that <tt class="computeroutput">v1</tt> and
        <tt class="computeroutput">v2</tt> contain values <span class="emphasis"><em>of distinct types</em></span>.
        Call these types <tt class="computeroutput">T</tt> and <tt class="computeroutput">U</tt>. At this point,
        since <tt class="computeroutput">variant</tt> manages its content on the stack, the
        left-hand side of the assignment (i.e., <tt class="computeroutput">v1</tt>) must destroy
        its content so as to permit in-place copy-construction of the content
        of the right-hand side (i.e., <tt class="computeroutput">v2</tt>). In the end, whereas
        <tt class="computeroutput">v1</tt> began with content of type <tt class="computeroutput">T</tt>, it ends
        with content of type <tt class="computeroutput">U</tt>, namely a copy of the content of
        <tt class="computeroutput">v2</tt>.</p><p>The crux of the problem, then, is this: in the event that
        copy-construction of the content of <tt class="computeroutput">v2</tt> fails, how can
        <tt class="computeroutput">v1</tt> maintain its "never-empty" guarantee?
        By the time copy-construction from <tt class="computeroutput">v2</tt> is attempted,
        <tt class="computeroutput">v1</tt> has already destroyed its content!</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="variant.design.never-empty.memcpy-solution"></a>The "Ideal" Solution: False Hopes</h5></div></div><div></div></div><p>Upon learning of this dilemma, clever individuals may propose the
        following scheme hoping to solve the problem:

        </p><div class="orderedlist"><ol type="1"><li>Provide some "backup" storage, appropriately
            aligned, capable of holding values of the contained type of the
            left-hand side.</li><li>Copy the memory (e.g., using <tt class="computeroutput">memcpy</tt>) of the
            storage of the left-hand side to the backup storage.</li><li>Attempt a copy of the right-hand side content to the
            (now-replicated) left-hand side storage.</li><li>In the event of an exception from the copy, restore the
            backup (i.e., copy the memory from the backup storage back into
            the left-hand side storage).</li><li>Otherwise, in the event of success, now copy the memory
            of the left-hand side storage to another "temporary"
            aligned storage.</li><li>Now restore the backup (i.e., again copying the memory)
            to the left-hand side storage; with the "old" content
            now restored, invoke the destructor of the contained type on the
            storage of the left-hand side.</li><li>Finally, copy the memory of the temporary storage to the
            (now-empty) storage of the left-hand side.</li></ol></div><p>While complicated, it appears such a scheme could provide the
        desired safety in a relatively efficient manner. In fact, several
        early iterations of the library implemented this very approach.</p><p>Unfortunately, as Dave Abraham's first noted, the scheme results
        in undefined behavior:

        </p><div class="blockquote"><blockquote class="blockquote"><p>"That's a lot of code to read through, but if it's
            doing what I think it's doing, it's undefined behavior.</p><p>"Is the trick to move the bits for an existing object
            into a buffer so we can tentatively construct a new object in
            that memory, and later move the old bits back temporarily to
            destroy the old object?</p><p>"The standard does not give license to do that: only one
            object may have a given address at a time. See 3.8, and
            particularly paragraph 4."</p></blockquote></div><p>Additionally, as close examination quickly reveals, the scheme has
        the potential to create irreconcilable race-conditions in concurrent
        environments.</p><p>Ultimately, even if the above scheme could be made to work on
        certain platforms with particular compilers, it is still necessary to
        find a portable solution.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="variant.design.never-empty.double-storage-solution"></a>An Initial Solution: Double Storage</h5></div></div><div></div></div><p>Upon learning of the infeasibility of the above scheme, Anthony
        Williams proposed in
        <a href="variant.refs.html#variant.refs.wil02">[Wil02]</a> a scheme that served
        as the basis for a portable solution in some pre-release
        implementations of <tt class="computeroutput">variant</tt>.</p><p>The essential idea to this scheme, which shall be referred to as
        the "double storage" scheme, is to provide enough space
        within a <tt class="computeroutput">variant</tt> to hold two separate values of any of
        the bounded types.</p><p>With the secondary storage, a copy the right-hand side can be
        attempted without first destroying the content of the left-hand side;
        accordingly, the content of the left-hand side remains available in
        the event of an exception.</p><p>Thus, with this scheme, the <tt class="computeroutput">variant</tt> implementation
        needs only to keep track of which storage contains the content -- and
        dispatch any visitation requests, queries, etc. accordingly.</p><p>The most obvious flaw to this approach is the space overhead
        incurred. Though some optimizations could be applied in special cases
        to eliminate the need for double storage -- for certain bounded types
        or in some cases entirely (see
        <a href="variant.design.html#variant.design.never-empty.optimizations" title="Enabling Optimizations">the section called &#8220;Enabling Optimizations&#8221;</a> for more
        details) -- many users on the Boost mailing list strongly objected to
        the use of double storage. In particular, it was noted that the
        overhead of double storage would be at play at all times -- even if
        assignment to <tt class="computeroutput">variant</tt> never occurred. For this reason
        and others, a new approach was developed.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="variant.design.never-empty.heap-backup-solution"></a>Current Approach: Temporary Heap Backup</h5></div></div><div></div></div><p>Despite the many objections to the double storage solution, it was
        realized that no replacement would be without drawbacks. Thus, a
        compromise was desired.</p><p>To this end, Dave Abrahams suggested to include the following in
        the behavior specification for <tt class="computeroutput">variant</tt> assignment:
        "<tt class="computeroutput">variant</tt> assignment from one type to another may
        incur dynamic allocation." That is, while <tt class="computeroutput">variant</tt> would
        continue to store its content <span class="emphasis"><em>in situ</em></span> after
        construction and after assignment involving identical contained types,
        <tt class="computeroutput">variant</tt> would store its content on the heap after
        assignment involving distinct contained types.</p><p>The algorithm for assignment would proceed as follows:

        </p><div class="orderedlist"><ol type="1"><li>Copy-construct the content of the right-hand side to the
            heap; call the pointer to this data <tt class="computeroutput">p</tt>.</li><li>Destroy the content of the left-hand side.</li><li>Copy <tt class="computeroutput">p</tt> to the left-hand side
            storage.</li></ol></div><p>

        Since all operations on pointers are nothrow, this scheme would allow
        <tt class="computeroutput">variant</tt> to meet its never-empty guarantee.
      </p><p>The most obvious concern with this approach is that while it
        certainly eliminates the space overhead of double storage, it
        introduces the overhead of dynamic-allocation to <tt class="computeroutput">variant</tt>
        assignment -- not just in terms of the initial allocation but also
        as a result of the continued storage of the content on the heap. While
        the former problem is unavoidable, the latter problem may be avoided
        with the following "temporary heap backup" technique:

        </p><div class="orderedlist"><ol type="1"><li>Copy-construct the content of the
            <span class="emphasis"><em>left</em></span>-hand side to the heap; call the pointer to
            this data <tt class="computeroutput">backup</tt>.</li><li>Destroy the content of the left-hand side.</li><li>Copy-construct the content of the right-hand side in the
            (now-empty) storage of the left-hand side.</li><li>In the event of failure, copy <tt class="computeroutput">backup</tt> to the
            left-hand side storage.</li><li>In the event of success, deallocate the data pointed to
            by <tt class="computeroutput">backup</tt>.</li></ol></div><p>With this technique: 1) only a single storage is used;
        2) allocation is on the heap in the long-term only if the assignment
        fails; and 3) after any <span class="emphasis"><em>successful</em></span> assignment,
        storage within the <tt class="computeroutput">variant</tt> is guaranteed. For the
        purposes of the initial release of the library, these characteristics
        were deemed a satisfactory compromise solution.</p><p>There remain notable shortcomings, however. In particular, there
        may be some users for which heap allocation must be avoided at all
        costs; for other users, any allocation may need to occur via a
        user-supplied allocator. These issues will be addressed in the future
        (see <a href="variant.design.html#variant.design.never-empty.roadmap" title="Future Direction: Policy-based Implementation">the section called &#8220;Future Direction: Policy-based Implementation&#8221;</a>). For now,
        though, the library treats storage of its content as an implementation
        detail. Nonetheless, as described in the next section, there
        <span class="emphasis"><em>are</em></span> certain things the user can do to ensure the
        greatest efficiency for <tt class="computeroutput">variant</tt> instances (see
        <a href="variant.design.html#variant.design.never-empty.optimizations" title="Enabling Optimizations">the section called &#8220;Enabling Optimizations&#8221;</a> for
        details).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="variant.design.never-empty.optimizations"></a>Enabling Optimizations</h5></div></div><div></div></div><p>As described in
        <a href="variant.design.html#variant.design.never-empty.problem" title="The Implementation Problem">the section called &#8220;The Implementation Problem&#8221;</a>, the central
        difficulty in implementing the never-empty guarantee is the
        possibility of failed copy-construction during <tt class="computeroutput">variant</tt>
        assignment. Yet types with nothrow copy constructors clearly never
        face this possibility. Similarly, if one of the bounded types of the
        <tt class="computeroutput">variant</tt> is nothrow default-constructible, then such a
        type could be used as a safe "fallback" type in the event of
        failed copy construction.</p><p>Accordingly, <tt class="computeroutput">variant</tt> is designed to enable the
        following optimizations once the following criteria on its bounded
        types are met:

        </p><div class="itemizedlist"><ul type="disc"><li>For each bounded type <tt class="computeroutput">T</tt> that is nothrow
            copy-constructible (as indicated by
            <tt class="computeroutput">boost::has_nothrow_copy</tt>), the
            library guarantees <tt class="computeroutput">variant</tt> will use only single
            storage and in-place construction for <tt class="computeroutput">T</tt>.</li><li>If <span class="emphasis"><em>any</em></span> bounded type is nothrow
            default-constructible (as indicated by
            <tt class="computeroutput">boost::has_nothrow_constructor</tt>),
            the library guarantees <tt class="computeroutput">variant</tt> will use only single
            storage and in-place construction for <span class="emphasis"><em>every</em></span>
            bounded type in the <tt class="computeroutput">variant</tt>. Note, however, that in
            the event of assignment failure, an unspecified nothrow
            default-constructible bounded type will be default-constructed in
            the left-hand side operand so as to preserve the never-empty
            guarantee.</li></ul></div><p><span class="bold"><b>Caveat</b></span>: On most platforms, the
        <a href="../../libs/type_traits/index.htm" target="_top">Type Traits</a> templates
        <tt class="computeroutput">has_nothrow_copy</tt> and <tt class="computeroutput">has_nothrow_constructor</tt>
        by default return <tt class="computeroutput">false</tt> for all <tt class="computeroutput">class</tt> and
        <tt class="computeroutput">struct</tt> types. It is necessary therefore to provide
        specializations of these templates as appropriate for user-defined
        types, as demonstrated in the following:

</p><pre class="programlisting">// ...in your code (at file scope)...

namespace boost {

  template &lt;&gt;
  struct has_nothrow_copy&lt; myUDT &gt;
    : mpl::true_
  {
  };

}
</pre><p><span class="bold"><b>Implementation Note</b></span>: So as to make
        the behavior of <tt class="computeroutput">variant</tt> more predictable in the aftermath
        of an exception, the current implementation prefers to default-construct
        <tt class="computeroutput">boost::blank</tt> if specified as a
        bounded type instead of other nothrow default-constructible bounded
        types. (If this is deemed to be a useful feature, it will become part
        of the specification for <tt class="computeroutput">variant</tt>; otherwise, it may be
        obsoleted. Please provide feedback to the Boost mailing list.)</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="variant.design.never-empty.roadmap"></a>Future Direction: Policy-based Implementation</h5></div></div><div></div></div><p>As the previous sections have demonstrated, much effort has been
        expended in an attempt to provide a balance between performance, data
        size, and heap usage. Further, significant optimizations may be
        enabled in <tt class="computeroutput">variant</tt> on the basis of certain traits of its
        bounded types.</p><p>However, there will be some users for whom the chosen compromise
        is unsatisfactory (e.g.: heap allocation must be avoided at all costs;
        if heap allocation is used, custom allocators must be used; etc.). For
        this reason, a future version of the library will support a
        policy-based implementation of <tt class="computeroutput">variant</tt>. While this will
        not eliminate the problems described in the previous sections, it will
        allow the decisions regarding tradeoffs to be decided by the user
        rather than the library designers.</p></div></div></div><table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr><td align="left"><small>Last revised:  ,  at  GMT</small></td><td align="right"><small>Copyright © 2002, 2003 Eric Friedman, Itay Maman</small></td></tr></table><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="id2544445-bb.html"><img src="images/prev.png" alt="Prev"></a> </td><td width="20%" align="center"><a accesskey="u" href="variant.html"><img src="images/up.png" alt="Up"></a></td><td width="40%" align="right"> <a accesskey="n" href="variant.misc.html"><img src="images/next.png" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">Function template visitor_ptr </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"></a></td><td width="40%" align="right" valign="top"> Miscellaneous Notes</td></tr></table></div></body></html>
