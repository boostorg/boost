<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Design Overview</title><link rel="stylesheet" href="reference.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><link rel="home" href="index.html" title="The Boost C++ Libraries"><link rel="up" href="signals.html" title="Boost.Signals"><link rel="previous" href="ch04s04.html" title="Frequently Asked Questions"><link rel="next" href="ch04s06.html" title="Design Rationale"><link rel="chapter" href="any.html" title="Boost.Any"><link rel="refentry" href="class.boost.bad_any_cast.html" title="Class bad_any_cast"><link rel="refentry" href="class.boost.any.html" title="Class any"><link rel="refentry" href="id2827840.html" title="Function any_cast"><link rel="chapter" href="function.html" title="Boost.Function"><link rel="refentry" href="id2837192.html" title="Class bad_function_call"><link rel="refentry" href="class.boost.function_base.html" title="Class function_base"><link rel="refentry" href="class.boost.functionN.html" title="Class template functionN"><link rel="refentry" href="class.boost.function.html" title="Class template function"><link rel="chapter" href="ref.html" title="Boost.Ref"><link rel="refentry" href="id2833212.html" title="Class template reference_wrapper"><link rel="refentry" href="id2695148.html" title="Class template is_reference_wrapper"><link rel="refentry" href="id2695230.html" title="Class template unwrap_reference"><link rel="chapter" href="signals.html" title="Boost.Signals"><link rel="refentry" href="class.boost.signalN.html" title="Class template signalN"><link rel="refentry" href="class.boost.signal.html" title="Class template signal"><link rel="refentry" href="class.boost.slot.html" title="Class template slot"><link rel="refentry" href="id2852290.html" title="Class trackable"><link rel="refentry" href="id2890015.html" title="Class connection"><link rel="refentry" href="id2877648.html" title="Class scoped_connection"><link rel="refentry" href="id2905241.html" title="Function template visit_each"><link rel="refentry" href="class.boost.last_value.html" title="Class template last_value"><link rel="refentry" href="id2830650.html" title="Class last_value&lt;void&gt;"><link rel="subsection" href="ch04s05.html#id2895772" title="Type Erasure"><link rel="subsection" href="ch04s05.html#id2895860" title="connection class"><link rel="subsection" href="ch04s05.html#id2895993" title="Slot Call Iterator"><link rel="subsection" href="ch04s05.html#id2896236" title="visit_each function template"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table border="1" cellpadding="2" bgcolor="#007F7F"><tr><td bgcolor="#FFFFFF"><img src="../../c%2B%2Bboost.gif" alt="c++boost.gif (8819 bytes)" width="277" height="86"></td><td><a href="../../index.htm"><font color="#FFFFFF" size="4" face="Arial">Home</font></a></td><td><a href="../../libs/libraries.htm"><font color="#FFFFFF" size="4" face="Arial">Libraries</font></a></td><td><a href="../../people/people.htm"><font color="#FFFFFF" size="4" face="Arial">People</font></a></td><td><a href="../../more/faq.htm"><font color="#FFFFFF" size="4" face="Arial">FAQ</font></a></td><td><a href="../../more/index.htm"><font color="#FFFFFF" size="4" face="Arial">More</font></a></td></tr></table><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2895766"></a>Design Overview</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2895772"></a>Type Erasure</h3></div></div><div></div></div><p>&quot;Type erasure&quot;, where static type information is eliminated
    by the use of dynamically dispatched interfaces, is used
    extensively within the Boost.Signals library to reduce the amount
    of code generated by template instantiation. Each signal must
    manage a list of slots and their associated connections, along
    with a <tt class="computeroutput">std::map</tt> to map from group identifiers to
    their associated connections. However, instantiating this map for
    every token type, and perhaps within each translation unit (for
    some popular template instantiation strategies) increase compile
    time overhead and space overhead.</p><p> To combat this so-called &quot;template bloat&quot;, we use
    Boost.Function and Boost.Any to store unknown types and
    operations. Then, all of the code for handling the list of slots
    and the mapping from slot identifiers to connections is factored
    into the class <tt class="computeroutput">signal_base</tt>
    that deals exclusively with the <tt class="computeroutput">any</tt> and
    <tt class="computeroutput"><a href="class.boost.function.html" title="Class template function">function</a></tt> objects, hiding the
    actual implementations using the well-known pimpl idiom. The
    actual <tt class="computeroutput"><a href="class.boost.signalN.html" title="Class template signalN">signalN</a></tt> class templates
    deal only with code that will change depending on the number of
    arguments or which is inherently template-dependent (such as
    connection).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2895860"></a><tt class="computeroutput">connection</tt> class</h3></div></div><div></div></div><p> The <tt class="computeroutput"><a href="id2890015.html" title="Class connection">connection</a></tt> class is
    central to the behavior of the Boost.Signals library. It is the
    only entity within the Boost.Signals system that has knowledge of
    all objects that are associated by a given connection. To be
    specific, the <tt class="computeroutput"><a href="id2890015.html" title="Class connection">connection</a></tt> class
    itself is merely a thin wrapper over a
    <tt class="computeroutput">shared_ptr</tt> to a
    <tt class="computeroutput">basic_connection</tt> object.</p><p> <tt class="computeroutput"><a href="id2890015.html" title="Class connection">connection</a></tt> objects are
    stored by all participants in the Signals system: each
    <tt class="computeroutput"><a href="id2852290.html" title="Class trackable">trackable</a></tt> object contains a
    list of <tt class="computeroutput"><a href="id2890015.html" title="Class connection">connection</a></tt> objects
    describing all connections it is a part of; similarly, all signals
    contain a set of pairs that define a slot. The pairs consist of a
    slot function object (generally a Boost.Function object) and a
    <tt class="computeroutput"><a href="id2890015.html" title="Class connection">connection</a></tt> object (that will
    disconnect on destruction). Finally, the mapping from slot groups
    to slots is based on the key value in a
    <tt class="computeroutput">std::multimap</tt> (the stored data
    in the <tt class="computeroutput">std::multimap</tt> is the
    slot pair).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2895993"></a>Slot Call Iterator</h3></div></div><div></div></div><p> The slot call iterator is conceptually a stack of iterator
    adaptors that modify the behavior of the underlying iterator
    through the list of slots. The following table describes the type
    and behavior of each iterator adaptor required. Note that this is
    only a conceptual model: the implementation collapses all these
    layers into a single iterator adaptor because several popular
    compilers failed to compile the implementation of the conceptual
    model.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Iterator Adaptor</th><th align="left">Purpose</th></tr></thead><tbody><tr><td align="left"><p>Slot List Iterator</p></td><td align="left"><p>An iterator through the list of slots
            connected to a signal. The <tt class="computeroutput">value_type</tt> of this
            iterator will be
            <tt class="computeroutput">std::pair&lt;any,
            connection&gt;</tt>, where the
            <tt class="computeroutput"><a href="class.boost.any.html" title="Class any">any</a></tt> contains an
            instance of the slot function type.</p></td></tr><tr><td align="left"><p>Filter Iterator Adaptor</p></td><td align="left"><p>This filtering iterator adaptor filters out
            slots that have been disconnected, so we never see a
            disconnected slot in later stages.</p></td></tr><tr><td align="left"><p>Projection Iterator Adaptor</p></td><td align="left"><p>The projection iterator adaptor returns a
            reference to the first member of the pair that constitutes
            a connected slot (e.g., just the
            <tt class="computeroutput"><a href="class.boost.any.html" title="Class any">boost::any</a></tt> object that
            holds the slot function).</p></td></tr><tr><td align="left"><p>Transform Iterator Adaptor</p></td><td align="left"><p>This transform iterator adaptor performs an
            <tt class="computeroutput"><a href="id2827840.html" title="Function any_cast">any_cast</a></tt> to
            extract a reference to the slot function with the
            appropriate slot function type.</p></td></tr><tr><td align="left"><p>Transform Iterator Adaptor</p></td><td align="left"><p>This transform iterator adaptor calls the
            function object returned by dereferencing the underlying
            iterator with the set of arguments given to the signal
            itself, and returns the result of that slot
            call.</p></td></tr><tr><td align="left"><p>Input Caching Iterator Adaptor</p></td><td align="left"><p>This iterator adaptor caches the result of
            dereferencing the underlying iterator. Therefore,
            dereferencing this iterator multiple times will only
            result in the underlying iterator being dereferenced once;
            thus, a slot can only be called once but its result can be
            used multiple times.</p></td></tr><tr><td align="left"><p>Slot Call Iterator</p></td><td align="left"><p>Iterates over calls to each slot.</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2896236"></a><tt class="computeroutput">visit_each</tt> function template</h3></div></div><div></div></div><p> The <tt class="computeroutput"><a href="id2905241.html" title="Function template visit_each">visit_each</a></tt>
    function template is a mechanism for discovering objects that are
    stored within another object. Function template
    <tt class="computeroutput"><a href="id2905241.html" title="Function template visit_each">visit_each</a></tt> takes three
    arguments: an object to explore, a visitor function object that is
    invoked with each subobject, and the <tt class="computeroutput">int</tt> 0. </p><p> The third parameter is merely a temporary solution to the
    widespread lack of proper function template partial ordering. The
    primary <tt class="computeroutput"><a href="id2905241.html" title="Function template visit_each">visit_each</a></tt>
    function template specifies this third parameter type to be
    <tt class="computeroutput">long</tt>, whereas any user specializations must specify
    their third parameter to be of type <tt class="computeroutput">int</tt>. Thus, even
    though a broken compiler cannot tell the ordering between, e.g., a
    match against a parameter <tt class="computeroutput">T</tt> and a parameter
    <tt class="computeroutput">A&lt;T&gt;</tt>, it can determine that the conversion from
    the integer 0 to <tt class="computeroutput">int</tt> is better than the conversion to
    <tt class="computeroutput">long</tt>. The ordering determined by this conversion thus
    achieves partial ordering of the function templates in a limited,
    but successful, way. The following example illustrates the use of
    this technique:</p><pre class="programlisting">
template&lt;typename&gt; class A {};
template&lt;typename T&gt; void foo(T, long);
template&lt;typename T&gt; void foo(A&lt;T&gt;, int);
A&lt;T&gt; at;
foo(at, 0);
</pre><p> In this example, we assume that our compiler can not tell
    that <tt class="computeroutput">A&lt;T&gt;</tt> is a better match than
    <tt class="computeroutput">T</tt>, and therefore assume that the function templates
    cannot be ordered based on that parameter. Then the conversion
    from 0 to <tt class="computeroutput">int</tt> is better than the conversion from 0 to
    <tt class="computeroutput">long</tt>, and the second function template is
    chosen. </p></div></div><table width="100%"><tr><td align="left"><small></small></td><td align="right"><small>Copyright © 2001-2003 Douglas Gregor</small></td></tr></table><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s04.html"><img src="images/prev.png" alt="Prev"></a> </td><td width="20%" align="center"><a accesskey="u" href="signals.html"><img src="images/up.png" alt="Up"></a></td><td width="40%" align="right"> <a accesskey="n" href="ch04s06.html"><img src="images/next.png" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">Frequently Asked Questions </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"></a></td><td width="40%" align="right" valign="top"> Design Rationale</td></tr></table></div></body></html>
