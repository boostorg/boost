#
# This is Boost Jamfile for Boost.Build V2.
# 
# Pass --v2 option to bjam to use this file. For example:
#
#    bjam --v2 link=static
#

# TODO:
#  - handle boost version


import modules ;
import set ;
import stage ;

constant BOOST_VERSION : 1.33.0 ;

project boost
    : requirements <include>.
      # disable auto-linking for all targets here,
      # primarily because it caused troubles with V2
      <define>BOOST_ALL_NO_LIB=1
      # Used to encode variant in target name. See the
      # 'tag' rule below.
      <tag>@$(__name__).tag
    : usage-requirements <include>.
    : build-dir bin.v2  
    ;

# The code here selects the libraries that must be built and builds
# and creates two targets:
# 'stage', which builds only libraries and placed them in one location
# 'install', which places both libraries and headers in system location



rule libraries-to-install ( existing-libraries * )
{
   local argv = [ modules.peek : ARGV ] ;
   local with-parameter = [ MATCH --with-(.*) : $(argv) ] ;
   local without-parameter = [ MATCH --without-(.*) : $(argv) ] ;

   # Do some checks
   if $(with-parameter) && $(without-parameter)
   {
       ECHO "error: both --with-<library> and --without-<library> specified" ;
       EXIT ;
   }
   
   local wrong = [ set.difference $(with-parameter) : $(existing-libraries) ] ;
   if $(wrong)
   {
       ECHO "error: wrong library name '$(wrong[1])' in the --with-<library> option." ;
       EXIT ;
   }
   local wrong = [ set.difference $(without-parameter) : $(existing-libraries) ] ;
   if $(wrong)
   {
       ECHO "error: wrong library name '$(wrong[1])' in the --without-<library> option." ;
       EXIT ;
   }

   if $(with-parameter)
   {
       return [ set.intersection $(existing-libraries) : $(with-parameter) ] ;
   }
   else
   {
       return [ set.difference $(existing-libraries) : $(without-parameter) ] ;
   }         
}

# The following is a copy of V1 logic. We don't yet support
# selecting versioned/unversioned install and changing the build
# directory.

ARGV = [ modules.peek : ARGV ] ;

# what kind of layout are we doing?
layout = [ MATCH "^--layout=(.*)" : $(ARGV) ] ;
layout ?= versioned ;
layout-$(layout) = true ;

# possible stage only location
local stage-locate = [ MATCH "^--stagedir=(.*)" : $(ARGV) ] ;
stage-locate ?= stage ;

# architecture independent files
local boost-locate ;
if ! $(with-stage)
{
    boost-locate = [ MATCH "^--prefix=(.*)" : $(ARGV) ] ;
}
else
{
    boost-locate = $(stage-locate) ;
}

if [ modules.peek : NT ] { boost-locate ?= C:\\Boost ; }
else if [ modules.peek : UNIX ] { boost-locate ?= /usr/local ; }

# architecture dependent files
local exec-locate = [ MATCH "^--exec-prefix=(.*)" : $(ARGV) ] ;
exec-locate ?= $(boost-locate) ;

# object code libraries
local lib-locate = [ MATCH "^--libdir=(.*)" : $(ARGV) ] ;
lib-locate ?= $(exec-locate)/lib ;

# where to build
local all-locate = [ MATCH "^--builddir=(.*)" : $(ARGV) ] ;
ALL_LOCATE_TARGET ?= $(all-locate) ;

# source header files
local include-locate = [ MATCH "^--includedir=(.*)" : $(ARGV) ] ;
include-locate ?= $(boost-locate)/include ;

# location of python
local python-root = [ MATCH "^--with-python-root=(.*)" : $(ARGV) ] ;
PYTHON_ROOT ?= $(python-root) ;


# Select the libraries to install.
libraries = [ MATCH .*libs/(.*)/build/.* : [ glob libs/*/build/Jamfile.v2 ] ] ;
libraries = [ libraries-to-install $(libraries) ] ;


# This rule is called by Boost.Build to determine the name of 
# target. We use it to encode build variant, compiler name and
# boost version in the target name 
rule tag ( name : type ? : property-set )
{
    if $(type) in STATIC_LIB SHARED_LIB IMPORT_LIB
    {        
        if $(layout) = versioned
        {
            name = [ stage.add-variant-and-compiler $(name) 
              : $(type) : $(property-set) ] ;
            
            local version-tag = [ MATCH "^([^.]+)[.]([^.]+)" : $(BOOST_VERSION[1]) ] ;
            version-tag = $(version-tag:J="_") ;
            
            # On NT, library with version suffix won't be recognized
            # by linkers. On CYGWIN, we get strage duplicate symbol
            # errors when library is generated with version suffix.
            if [ $(property-set).get <os> ] in NT CYGWIN
            {
                return $(name:B)-$(version-tag)$(name:S) ;
            }
            else
            {
                return $(name:B)-$(version-tag)$(name:S).$(BOOST_VERSION)  ;
            }
        }
        else
        {
            return [ stage.add-variant-and-compiler $(name) 
              : $(type) : $(property-set) ] ;
        }
    }
}

# Install to system location.

alias install : install-libs install-headers ;

install install-libs : libs/$(libraries)/build   
  : <so-version>1.33.0 
    <location>$(lib-locate) 
  ;

local patterns = *.hpp *.ipp *.h *.inc ;
local dirs = boost boost/* boost/*/* ;
install install-headers : 
  [ glob $(dirs)/$(patterns) ]
  :  
  <location>$(include-locate)
  <install-source-root>.
  ;  

# Install just library.
install stage : libs/$(libraries)/build 
  : <location>$(stage-locate)
  ;

explicit install install-libs install-headers stage ;        

# Just build the libraries, don't install them anywhere.
# This is what happend with just "bjam --v2".
alias build_all : libs/$(libraries)/build ;


# Make project ids of all libraries known.

for local l in $(libraries)
{
    use-project /boost/$(l) : libs/$(l)/build ;
}
    